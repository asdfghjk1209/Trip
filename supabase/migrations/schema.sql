-- ============================================================
-- ğŸš¨ 1. æ¯ç­é˜¶æ®µ (æ¸…ç†æ—§æ•°æ®å’Œå†²çª)
-- ============================================================
-- åˆ é™¤å†²çªçš„å‡½æ•° (è§£å†³ "cannot change name of input parameter" æŠ¥é”™)
DROP FUNCTION IF EXISTS get_trip_owner(bigint) CASCADE;

-- åˆ é™¤æ‰€æœ‰ç›¸å…³è¡¨ (è§£å†³è¡¨ç»“æ„ä¸ä¸€è‡´ã€ç¼ºåˆ—ã€ä¾èµ–æ­»é”ç­‰é—®é¢˜)
-- æ³¨æ„ï¼šCASCADE ä¼šè‡ªåŠ¨æ¸…ç†å…³è”çš„ RLS ç­–ç•¥ï¼Œä¸ç”¨æ‰‹åŠ¨åˆ ç­–ç•¥
DROP TABLE IF EXISTS public.memories CASCADE;
DROP TABLE IF EXISTS public.comments CASCADE;
DROP TABLE IF EXISTS public.likes CASCADE;
DROP TABLE IF EXISTS public.trip_members CASCADE;
DROP TABLE IF EXISTS public.activities CASCADE;
DROP TABLE IF EXISTS public.days CASCADE;
DROP TABLE IF EXISTS public.trips CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- ============================================================
-- ğŸ—ï¸ 2. é‡å»ºé˜¶æ®µ (åˆ›å»ºå®Œç¾ç»“æ„çš„è¡¨)
-- ============================================================
create extension if not exists "uuid-ossp";

-- [è¡¨ 1] ç”¨æˆ·æ¡£æ¡ˆè¡¨ (Profiles) - å¿…é¡»æœ€å…ˆåˆ›å»ºï¼Œä»¥ä¾¿å…¶ä»–è¡¨å¼•ç”¨
create table public.profiles (
  id uuid references auth.users(id) on delete cascade primary key,
  email text,
  full_name text unique,
  avatar_url text,
  notification_settings jsonb default '{"email_updates": true, "push_invites": true, "push_comments": true}'::jsonb,
  updated_at timestamp with time zone
);

-- å‡½æ•°ï¼šæ–°å»ºç”¨æˆ·æ—¶è‡ªåŠ¨åˆ›å»º Profile
create or replace function public.handle_new_user() 
returns trigger as $$
begin
  insert into public.profiles (id, email, full_name, avatar_url)
  values (new.id, new.email, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

-- è§¦å‘å™¨ï¼šæ³¨å†Œåè§¦å‘
create or replace trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- å‡½æ•°ï¼šæ›´æ–°ç”¨æˆ·æ—¶åŒæ­¥ Profile
create or replace function public.handle_user_update() 
returns trigger as $$
begin
  update public.profiles
  set full_name = new.raw_user_meta_data->>'full_name',
      avatar_url = new.raw_user_meta_data->>'avatar_url',
      email = new.email,
      updated_at = now()
  where id = new.id;
  return new;
end;
$$ language plpgsql security definer;

-- è§¦å‘å™¨ï¼šæ›´æ–°åè§¦å‘
create or replace trigger on_auth_user_updated
  after update on auth.users
  for each row execute procedure public.handle_user_update();

-- ğŸ› ï¸ è¡¥æ•‘æªæ–½ï¼šåŒæ­¥ç°æœ‰ç”¨æˆ·åˆ° Profiles (é˜²æ­¢é‡ç½®æ•°æ®åº“åè€ç”¨æˆ·æ— æ³•åˆ›å»ºè¡Œç¨‹)
insert into public.profiles (id, email, full_name, avatar_url)
select 
  id, 
  email, 
  raw_user_meta_data->>'full_name', 
  raw_user_meta_data->>'avatar_url'
from auth.users
on conflict (id) do nothing;


-- [è¡¨ 2] è¡Œç¨‹è¡¨ (Trips)
create table public.trips (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  title text not null,
  start_date date,
  cover_image text,
  is_public boolean default false,
  user_id uuid references public.profiles(id) on delete cascade, -- å…³è”åˆ° profiles
  budget numeric default 0,
  description text
);

-- [è¡¨ 3] å¤©æ•°è¡¨ (Days)
create table public.days (
  id bigint generated by default as identity primary key,
  trip_id bigint references public.trips(id) on delete cascade not null,
  day_index int not null,
  date date,
  title text
);

-- [è¡¨ 4] æ´»åŠ¨è¡¨ (Activities)
create table public.activities (
  id bigint generated by default as identity primary key,
  day_id bigint references public.days(id) on delete cascade not null,
  type text default 'spot',
  title text not null,
  location text,
  lat double precision,
  lng double precision,
  time time,
  memo text,
  sort_order int default 0,
  transport_mode text,
  is_tentative boolean default false,
  images text[] default '{}',
  cost numeric default 0,
  transport_time text,
  transport_distance text,
  transport_cost numeric default 0,
  link text
);

-- [è¡¨ 5] æˆå‘˜åä½œè¡¨ (Trip Members)
create table public.trip_members (
  id bigint generated by default as identity primary key,
  trip_id bigint references public.trips(id) on delete cascade not null,
  user_id uuid references public.profiles(id) on delete cascade not null, -- å…³è”åˆ° profiles
  role text check (role in ('viewer', 'editor', 'owner')) default 'viewer',
  email text, -- å¯é€‰ (å…è®¸ä¸ºç©º)
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(trip_id, user_id) -- å”¯ä¸€çº¦æŸ
);

-- ============================================================
-- ğŸ“¦ 3. å­˜å‚¨æ¡¶é…ç½®
-- ============================================================
insert into storage.buckets (id, name, public) 
values ('trip_images', 'trip_images', true)
on conflict (id) do nothing;

drop policy if exists "Public Access" on storage.objects;
drop policy if exists "Public Upload" on storage.objects;

create policy "Public Access" on storage.objects for select using ( bucket_id = 'trip_images' );
create policy "Public Upload" on storage.objects for insert with check ( bucket_id = 'trip_images' );

-- [è¡¨ 5] çµæ„Ÿå›å¿†è¡¨ (Memories)
create table public.memories (
  id bigint generated by default as identity primary key,
  trip_id bigint references public.trips(id) on delete cascade not null,
  user_id uuid references public.profiles(id) on delete cascade not null, -- å…³è”åˆ° profiles
  content text,
  images text[] default '{}',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- [è¡¨ 6] è¯„è®ºè¡¨ (Comments)
create table public.comments (
  id bigint generated by default as identity primary key,
  memory_id bigint references public.memories(id) on delete cascade not null,
  user_id uuid references public.profiles(id) on delete cascade not null, -- å…³è”åˆ° profiles
  content text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- [è¡¨ 7] ç‚¹èµè¡¨ (Likes)
create table public.likes (
  id bigint generated by default as identity primary key,
  memory_id bigint references public.memories(id) on delete cascade not null,
  user_id uuid references public.profiles(id) on delete cascade not null, -- å…³è”åˆ° profiles
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(memory_id, user_id)
);

-- ============================================================
-- âš¡ 4. å®æ—¶åŒæ­¥ (Realtime)
-- ============================================================
begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime for table public.trips, public.days, public.activities, public.trip_members, public.memories, public.comments, public.likes;
commit;

-- ============================================================
-- ğŸ›¡ï¸ 5. å®‰å…¨ç­–ç•¥ (RLS)
-- ============================================================
alter table public.trips enable row level security;
alter table public.days enable row level security;
alter table public.activities enable row level security;
alter table public.trip_members enable row level security;
alter table public.profiles enable row level security;
alter table public.memories enable row level security;
alter table public.comments enable row level security;
alter table public.likes enable row level security;

-- ... (Existing Profile Policies) ...

-- (E) Memories, Comments, Likes ç­–ç•¥
-- åªè¦èƒ½çœ‹è¡Œç¨‹(trip)ï¼Œå°±èƒ½çœ‹ç›¸å…³çš„å†…å®¹
create policy "Memories viewable" on memories for select using (
  exists (select 1 from trips where id = memories.trip_id and (is_public = true or user_id = auth.uid()))
  or exists (select 1 from trip_members where trip_id = memories.trip_id and user_id = auth.uid())
);
create policy "Comments viewable" on comments for select using (
  exists (select 1 from memories m join trips t on m.trip_id = t.id where m.id = comments.memory_id and (t.is_public = true or t.user_id = auth.uid()))
  or exists (select 1 from memories m join trip_members tm on m.trip_id = tm.trip_id where m.id = comments.memory_id and tm.user_id = auth.uid())
);
create policy "Likes viewable" on likes for select using (
  exists (select 1 from memories m join trips t on m.trip_id = t.id where m.id = likes.memory_id and (t.is_public = true or t.user_id = auth.uid()))
  or exists (select 1 from memories m join trip_members tm on m.trip_id = tm.trip_id where m.id = likes.memory_id and tm.user_id = auth.uid())
);

-- åªæœ‰å‚ä¸è€…(Member)æˆ–Ownerå¯ä»¥å‘å¸ƒ/è¯„è®º/ç‚¹èµ
create policy "Memories insertable" on memories for insert with check (
  exists (select 1 from trips where id = trip_id and user_id = auth.uid())
  or exists (select 1 from trip_members where trip_id = memories.trip_id and user_id = auth.uid())
);
create policy "Comments insertable" on comments for insert with check (
  exists (select 1 from memories m join trips t on m.trip_id = t.id where m.id = memory_id and t.user_id = auth.uid())
  or exists (select 1 from memories m join trip_members tm on m.trip_id = tm.trip_id where m.id = memory_id and tm.user_id = auth.uid())
);
create policy "Likes insertable" on likes for insert with check (
  exists (select 1 from memories m join trips t on m.trip_id = t.id where m.id = memory_id and t.user_id = auth.uid())
  or exists (select 1 from memories m join trip_members tm on m.trip_id = tm.trip_id where m.id = memory_id and tm.user_id = auth.uid())
);
-- åˆ é™¤è‡ªå·±çš„
create policy "Memories deletable" on memories for delete using (user_id = auth.uid());
create policy "Comments deletable" on comments for delete using (user_id = auth.uid());
create policy "Likes deletable" on likes for delete using (user_id = auth.uid());

-- Profiles ç­–ç•¥
create policy "Public profiles are viewable by everyone" on profiles for select using (true);
create policy "Users can update own profile" on profiles for update using (auth.uid() = id);

-- (D) ç”¨æˆ·è‡ªæ¯è´¦æˆ·åŠŸèƒ½
create or replace function delete_own_account()
returns void
language plpgsql
security definer
as $$
begin
  -- åˆ é™¤ auth.users ä¼šè‡ªåŠ¨çº§è”åˆ é™¤ profiles ç­‰æ‰€æœ‰å…³è”æ•°æ®(å¦‚æœå¤–é”®è®¾ç½®æ­£ç¡®)
  delete from auth.users where id = auth.uid();
end;
$$;

-- ã€å…³é”®å‡½æ•°ã€‘
create function get_trip_owner(target_trip_id bigint)
returns uuid
language sql
security definer
set search_path = public
as $$
  select user_id from trips where id = target_trip_id;
$$;

-- (A) Trips ç­–ç•¥
create policy "Trips viewable" on trips for select using (
  is_public = true 
  or auth.uid() = user_id 
  or exists (select 1 from trip_members where trip_id = trips.id and user_id = auth.uid())
);
create policy "Trips owner manage" on trips for all using (
  auth.uid() = user_id
);

-- (B) Trip Members ç­–ç•¥
create policy "Members view" on trip_members for select using (
  user_id = auth.uid() 
  or auth.uid() = get_trip_owner(trip_id)
);
create policy "Members leave" on trip_members for delete using (
  user_id = auth.uid()
);
create policy "Owner manage members" on trip_members for insert with check (
  auth.uid() = get_trip_owner(trip_id)
);
create policy "Owner delete members" on trip_members for delete using (
  auth.uid() = get_trip_owner(trip_id)
);

-- (C) Days & Activities ç­–ç•¥
-- æŸ¥çœ‹
create policy "Content viewable" on days for select using (
  exists (select 1 from trips where id = days.trip_id and (is_public = true or user_id = auth.uid()))
  or exists (select 1 from trip_members where trip_id = days.trip_id and user_id = auth.uid())
);
create policy "Content viewable" on activities for select using (
  exists (
    select 1 from days join trips on days.trip_id = trips.id 
    where days.id = activities.day_id 
    and (trips.is_public = true or trips.user_id = auth.uid())
  )
  or exists (
    select 1 from days join trip_members on days.trip_id = trip_members.trip_id
    where days.id = activities.day_id and trip_members.user_id = auth.uid()
  )
);
-- ç¼–è¾‘
create policy "Content editable" on days for all using (
  exists (select 1 from trips where id = days.trip_id and user_id = auth.uid())
  or exists (select 1 from trip_members where trip_id = days.trip_id and user_id = auth.uid() and role in ('editor', 'owner'))
);
create policy "Content editable" on activities for all using (
  exists (
    select 1 from days join trips on days.trip_id = trips.id 
    where days.id = activities.day_id and trips.user_id = auth.uid()
  )
  or exists (
    select 1 from days join trip_members on days.trip_id = trip_members.trip_id
    where days.id = activities.day_id and trip_members.user_id = auth.uid() and role in ('editor', 'owner')
  )
);
